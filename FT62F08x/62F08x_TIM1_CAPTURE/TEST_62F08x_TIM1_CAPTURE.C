//********************************************************* 
/*  文件名: TEST_62F08x_TIM1_CAPTURE.c
*	功能：  FT62F08x_TIM1_CAPTURE功能演示
*   IC:    FT62F088 LQFP32
*   内部：  16M
*	empno: 500                                
*   说明：  例程通过TIM1的捕获通道1测量TIM4输出到RB3的波形的周期（4K）
*		   TIM1计数器捕获的数据放在testdata数组里，一共20个。
*          程序只用到一个数据(testdata[1])来计算周期。		    
*
*   参考原理图 TEST_62F08x_sch.pdf
*/
//*********************************************************
#include "SYSCFG.h"
//*********************************************************
//***********************宏定义*****************************
#define  unchar     unsigned char 
#define  unint      unsigned int
#define  unlong     unsigned long

#define  DemoPortOut	RB3   
#define  DemoPortOut1	RB4

//volatile  unchar mydata; //全局查看变量定义
volatile unint testdata[20];
volatile unchar   y=0;
volatile unchar dataH;
volatile unchar dataL;
volatile unint  period=0;
/*-------------------------------------------------
 *  函数名：中断
 *	功能： 
 *  输入：  无
 *  输出：  无
 --------------------------------------------------*/
void interrupt ISR(void)            	
{ 
  	//定时器4的中断处理**********************
	if(T4UIE && T4UIF)                	
	{
		T4UIF = 1;                    	//写1清零标志位             
		DemoPortOut = ~DemoPortOut; 	//翻转电平
	} 
    if(T1CC1IE && T1CC1IF)              //捕获中断
    {
    	T1CC1IF=1;
        
        T1CC1OF=0;
        DemoPortOut1 = ~DemoPortOut1;   //捕获中断调试查看         
        dataH = TIM1CCR1H;
        dataL = TIM1CCR1L;
        testdata[y++] =(unint)(dataH<<8 | dataL);
        NOP();
        
        if(y>=20)
        {
        	y=0;
            
            //计算周期(us)
            period = testdata[1]/32;   //周期约等于250us
        }
    }
}  
/*-------------------------------------------------
 *  函数名：POWER_INITIAL
 *	功能：  上电系统初始化
 *  输入：  无
 *  输出：  无
 --------------------------------------------------*/	
void POWER_INITIAL (void) 
{
	 
	OSCCON = 0B01110001;	//WDT 32KHZ IRCF=111=16MHZ
					 		//Bit0=1,系统时钟为内部振荡器
					 		//Bit0=0,时钟源由FOSC<2：0>决定即编译选项时选择
	INTCON = 0;  			//暂禁止所有中断
    
	PORTA = 0B00000000;		
	TRISA = 0B11111111;		//PA输入输出 0-输出 1-输入
	PORTB = 0B00000000;		
	TRISB = 0B11100111;		//PB输入输出 0-输出 1-输入							
	PORTC = 0B00000000; 	
	TRISC = 0B11111111;		//PC输入输出 0-输出 1-输入  	
    PORTD = 0B00000000;		
	TRISD = 0B11111111;		//PD输入输出 0-输出 1-输入
	
	WPUA = 0B00000000;     	//PA端口上拉控制 1-开上拉 0-关上拉
	WPUB = 0B00000000;     	//PB端口上拉控制 1-开上拉 0-关上拉
	WPUC = 0B00000000;     	//PC端口上拉控制 1-开上拉 0-关上拉
	WPUD = 0B00000000;     	//PD端口上拉控制 1-开上拉 0-关上拉
    
    WPDA = 0B00000000;     	//PA端口上拉控制 1-开下拉 0-关下拉
	WPDB = 0B00000000;     	//PB端口上拉控制 1-开下拉 0-关下拉
	WPDC = 0B00000000;     	//PC端口上拉控制 1-开下拉 0-关下拉
	WPDD = 0B00000000;     	//PD端口上拉控制 1-开下拉 0-关下拉
    
    PSRC0  = 0B11111111;  	//PORTA,PORTB源电流设置最大
    //BIT7~BIT6:PORTB[7:4]源电流能力控制,BIT5~BIT4:PORTB[3:0]源电流能力控制 
    //BIT3~BIT2:PORTA[7:4]源电流能力控制,BIT1~BIT0:PORTA[3:0]源电流能力控制
    
    PSRC1  = 0B11111111;    //PORTC,PORTD源电流设置最大    
    //BIT7~BIT6:PORTD[7:4]源电流能力控制,BIT5~BIT4:PORTD[3:0]源电流能力控制 
    //BIT3~BIT2:PORTC[7:4]源电流能力控制,BIT1~BIT0:PORTC[3:0]源电流能力控制
    
    PSINK0 = 0B11111111;  	//PORTA灌电流设置最大 0:最小，1:最大
    PSINK1 = 0B11111111; 	//PORTB灌电流设置最大 0:最小，1:最大
    PSINK2 = 0B11111111;	//PORTC灌电流设置最大 0:最小，1:最大
    PSINK3 = 0B11111111;	//PORTD灌电流设置最大 0:最小，1:最大
	
    ANSELA = 0B00000000;    //全为数字管脚
 
}
/*------------------------------------------------- 
 *	函数名称：DelayUs
 *	功能：   短延时函数 --16M-2T--大概快1%左右.
 *	输入参数：Time延时时间长度 延时时长Time Us
 *	返回参数：无 
 -------------------------------------------------*/
void DelayUs(unsigned char Time)
{
	unsigned char a;
	for(a=0;a<Time;a++)
	{
		NOP();
	}
}                  
/*-------------------------------------------------
 *	函数名称：DelayMs
 *	功能：   短延时函数
 *	输入参数：Time延时时间长度 延时时长Time ms
 *	返回参数：无 
 -------------------------------------------------*/
void DelayMs(unsigned char Time)
{
	unsigned char a,b;
	for(a=0;a<Time;a++)
	{
		for(b=0;b<5;b++)
		{
		 	DelayUs(197); //快1%
		}
	}
}
/*-------------------------------------------------
 *	函数名称：DelayS
 *	功能：   短延时函数
 *	输入参数：Time延时时间长度 延时时长Time S
 *	返回参数：无 
 -------------------------------------------------*/
void DelayS(unsigned char Time)
{
	unsigned char a,b;
	for(a=0;a<Time;a++)
	{
		for(b=0;b<10;b++)
		{
		 	DelayMs(100); 
		}
	}
}
/*-------------------------------------------------
 *	函数名称：Time4Initial
 *	功能：  
 *	输入参数：
 *	返回参数：无 
 -------------------------------------------------*/
void Time4Initial(void)
{
	PCKEN |=0B00001000;      //TIME4模块时钟使能		
    
    TIM4CR1	=0B00000001;
    //BIT7: 0：TIM1_ARR寄存器没有缓冲，它可以被直接写入; 1：TIM1_ARR寄存器由预装载缓冲器缓冲。
    //BIT6:保留
    //BIT5~BIT4:timer4时钟选择位。
        		//00：系统时钟/主时钟
				//01：内部快时钟HIRC
				//10：LP时钟，只有当FOSC选择LP模式时才有意义
				//11：XT时钟，只有当FOSC选择XT模式时才有意义

    //BIT3:
    //			0：在发生更新事件时，计数器不停止；
	//			1：在发生下一次更新事件(清除CEN位)时，计数器停止。

    //BIT2:
   	// 		0：如果UDIS允许产生更新事件，则下述任一事件产生一个更新中断：
				//寄存器被更新(计数器上溢/下溢)
				//软件设置UG位
				//时钟/触发控制器产生的更新
	//		1：如果UDIS允许产生更新事件，则只有当下列事件发生时才产生更新中断，并UIF置1：
				//寄存器被更新(计数器上溢/下溢)

    //BIT1:
    //		0：一旦下列事件发生，产生更新(UEV)事件：
				//计数器溢出/下溢
				//产生软件更新事件
				//时钟/触发模式控制器产生的硬件复位被缓存的寄存器被装入它们的预装载值。
	//		1：不产生更新事件，影子寄存器(ARR、PSC、CCRx)保持它们的值。如果设置了UG位或时钟/触发控制器发出了一个硬件复位，则计数器和预分频器被重新初始化。

    // BIT0: 0：禁止计数器；1：使能计数器。


    TIM4IER	=0B00000001;
    //BIT0:  0：禁止更新中断；1：允许更新中断。

    TIM4SR	=0B00000000;
    //BIT0:当产生更新事件时该位由硬件置1。它由软件写1清0
			//0：无更新事件产生；
			//1：更新事件等待响应。当寄存器被更新时该位由硬件置1：
			//若TIM4_CR1寄存器的UDIS=0，当计数器上溢或下溢时；
			//若TIM4_CR1寄存器的UDIS=0、URS=0，当设置TIM4_EGR寄存器的UG位软件对计数器
			//CNT重新初始化时；
			//若TIM4_CR1寄存器的UDIS=0、URS=0，当计数器CNT被触发事件重新初始化时。

    TIM4EGR	=0B00000000;
    //BIT0:该位由软件置1，由硬件自动清0。
	//0：无动作；
	//1：重新初始化计数器，并产生一个更新事件。注意预分频器的计数器也被清0(但是预分频系数不变)。若在中心对称模式下或DIR=0(向上计数)则计数器被清0；若DIR=1(向下计数)则计数器取TIM1_ARR的值。

    TIM4CNTR=0; //TIM4 8位计数器
    
    TIM4PSCR=0B00000100;
    //预分频器对输入的CK_PSC时钟进行分频。
	//计数器的时钟频率fCK_CNT等于fCK_PSC/2(PSC[2:0])。PSC[7:3]由硬件清0。
	//PSCR包含了当更新事件产生时装入当前预分频器寄存器的值(包括由于清除TIMx_EGR寄存器的UG位产生的计数器清除事件)。这意味着如要新的预分频值生效，必须产生更新事件或者CEN=0。

    TIM4ARR	=124;
    //ARR包含了将要装载入实际的自动重装载寄存器的值。
	//当自动重装载的值为空时，计数器不工作。

    INTCON |= 0B11000000;    //开总中断和外设中断
  }
/*-------------------------------------------------
 *  函数名：Time1Initial
 *	功能：  上电系统初始化
 *  输入：  无
 *  输出：  无
 --------------------------------------------------*/		
void Time1_Capture_Initial(void)
{
	PCKEN |=0B00000010;    //使能timer1时钟模块
    CKOCON=0B00100000;
    TCKSRC=0B00000011;    //TIM1时钟为HIRC的2倍频
    //BIT7低频内振模式：1 = 256K 振荡频率模式,0 = 32K 振荡频率模式
    //BIT6~BIT4TIM2时钟源选择位
			//值	时钟源
			//0	系统时钟/主时钟
			//1	HIRC
			//2	XT时钟/外部时钟
			//3	HIRC的2倍频
			//4	XT时钟/外部时钟的2倍频
			//5	LIRC
			//6	LP时钟/外部时钟
			//7	LP时钟/外部时钟的2位频
		//BIT3:保留位
		//BIT2~BIT1:TIM1时钟源选择位
			//值	时钟源
			//0	系统时钟/主时钟
			//1	HIRC
			//2	XT时钟/外部时钟
			//3	HIRC的2倍频
			//4	XT时钟/外部时钟的2倍频
			//5	LIRC
			//6	LP时钟/外部时钟
			//7	LP时钟/外部时钟的2位频


    TIM1CR1 =0B00000110;  //预载允许，边沿对齐向上计数器，计数器使能
    //BIT7:自动预装载允许位
			//0：TIM1_ARR寄存器没有缓冲，它可以被直接写入；
			//1：TIM1_ARR寄存器由预装载缓冲器缓冲。
		//BIT6~BIT5:选择对齐模式
			//00：边沿对齐模式。计数器依据方向位(DIR)向上或向下计数。
			//01：中央对齐模式1。计数器交替地向上和向下计数。配置为输出的通道(TIM1_CCMRx寄存器中CciS=00)的输出比较中断标志位，只在计数器向下计数时被置1。 
			//10:中央对齐模式2。计数器交替地向上和向下计数。配置为输出的通道(TIM1_CCMRx寄存器中CciS=00)的输出比较中断标志位，只在计数器向上计数时被置1。
			//11：中央对齐模式3。计数器交替地向上和向下计数。配置为输出的通道(TIM1_CCMRx寄存器中CciS=00)的输出比较中断标志位，在计数器向上和向下计数时均被置1。
		//BIT4:方向
			//0：计数器向上计数；
			//1：计数器向下计数。
		//BIT3:单脉冲模式
			//0：在发生更新事件时，计数器不停止；
			//1：在发生下一次更新事件(清除CEN位)时，计数器停止。
		//BIT2:更新请求源
			//0：如果UDIS允许产生更新事件，则下述任一事件产生一个更新中断：
			//寄存器被更新(计数器上溢/下溢)
			//软件设置UG位
			//时钟/触发控制器产生的更新
			//1：如果UDIS允许产生更新事件，则只有当下列事件发生时才产生更新中断，并UIF置1：
			//寄存器被更新(计数器上溢/下溢)
		//BIT1:	禁止更新
			//0：一旦下列事件发生，产生更新(UEV)事件：
			//计数器溢出/下溢
			//产生软件更新事件
			//时钟/触发模式控制器产生的硬件复位被缓存的寄存器被装入它们的预装载值。
			//1：不产生更新事件，影子寄存器(ARR、PSC、CCRx)保持它们的值。如果设置了UG位或时钟/触发控制器发出了一个硬件复位，则计数器和预分频器被重新初始化。
		//BIT0	允许计数器
			//0：禁止计数器；
			//1：使能计数器。


    //TIM1SMCR =0B01110000;
    //TIM1SMCR|=0B00000101;
    TIM1SMCR =0B01010000;
    //TIM1SMCR|=0B00000110;
    TIM1SMCR|=0B00000100;

	    //BIT7：主/从模式
			//0：无作用；
			//1：触发输入(TRGI)上的事件被延迟了，以允许定时器1与它的从定时器间的完美同步(通过TRGO)。

		//BIT6~BIT4：触发选择,这3位选择用于选择同步计数器的触发输入。
			//000：内部触发ITR0连接到TIM6 TRGO (此设计没有TIM6，所以固定接0)	
			//001：保留	
			//010：内部触发ITR2连接到TIM5 TRGO(此设计没有TIM5，所以固定接0)
			//011：保留	
			//100：TI1的边沿检测器(TI1F_ED)
			//101：滤波后的定时器输入1(TI1FP1)
			//110：滤波后的定时器输入2(TI2FP2)
			//111：外部触发输入(ETRF)
			//注：这些位只能在未用到(如SMS=000)时被改变，以避免在改变时产生错误的边沿检测。
		//BIT3:保留
		//BIT2~BIT0：时钟/触发/从模式选择,当选择了外部信号，触发信号(TRGI)的有效边沿与选中的外部输入极性相关(见输入控制寄存器和控制寄存器的说明)
			//000：时钟/触发控制器禁止 C 如果CEN=1，则预分频器直接由内部时钟驱动。
			//001：编码器模式1 C 根据TI1FP1的电平，计数器在TI2FP2的边沿向上/下计数。
			//010：编码器模式2 C 根据TI2FP2的电平，计数器在TI1FP1的边沿向上/下计数。
			//011：编码器模式3 C 根据另一个输入的电平，计数器在TI1FP1和TI2FP2的边沿向上/下计数。
			//100：复位模式 C 在选中的触发输入(TRGI)的上升沿时重新初始化计数器，并且产生一个更新寄存器的信号。
			//101：门控模式 C 当触发输入(TRGI)为高时，计数器的时钟开启。一旦触发输入变为低，则计数器停止(但不复位)。计数器的启动和停止都是受控的。
			//110：触发模式 C 计数器在触发输入TRGI的上升沿启动(但不复位)，只有计数器的启动是受控的。
			//111：外部时钟模式1 C 选中的触发输入(TRGI)的上升沿驱动计数器。
			//注：如果TI1F_ED被选为触发输入(TS=100)时，不要使用门控模式。这是因为TI1F_ED在每次
			//TI1F变化时只是输出一个脉冲，然而门控模式是要检查触发输入的电平。

    TIM1IER =0B00000010;//捕获比较1中断使能
    //BIT7：允许刹车中断
			//0：禁止刹车中断；
			//1：允许刹车中断。
		//BIT6：触发中断使能
			//0：禁止触发中断；
			//1：使能触发中断。
		//BIT5：允许COM中断
			//0：禁止COM中断；
			//1：允许COM中断。
		//BIT4：允许捕获/比较4中断
			//0：禁止捕获/比较4中断；
			//1：允许捕获/比较4中断。
		//BIT3：允许捕获/比较3中断
			//0：禁止捕获/比较3中断；
			//1：允许捕获/比较3中断。
		//BIT2：允许捕获/比较2中断
			//0：禁止捕获/比较2中断；
			//1：允许捕获/比较2中断。
		//BIT1：允许捕获/比较1中断
			//0：禁止捕获/比较1中断；
			//1：允许捕获/比较1中断。
		//BIT0：允许更新中断
			//0：禁止更新中断；
			//1：允许更新中断。

    TIM1SR1 =0B00000000; //T1CC1IF
    //BIT7：刹车中断标记,一旦刹车输入有效，由硬件对该位置1。如果刹车输入无效，则该位可由软件清0。
			//0：无刹车事件产生；
			//1：刹车输入上检测到有效电平。
		//BIT6：触发器中断标记,当发生触发事件(当从模式控制器处于除门控模式外的其它模式时，在TRGI输入端检测到有效边沿，或门控模式下的任一边沿)时由硬件对该位置1。它由软件清0。                                        
			//0：无触发器事件产生；
			//1：触发中断等待响应。
		//BIT5：COM中断标记,一旦产生COM事件(当捕获/比较控制位：CciE、CciNE、OciM已被更新)该位由硬件置1。它由软件清0 。                                                                                                                                                  
			//0：无COM事件产生；
			//1：COM中断等待响应。
		//BIT4：捕获/比较4中断标记
			//参考CC1IF描述。
		//BIT3：捕获/比较3中断标记
			//参考CC1IF描述。
		//BIT2：捕获/比较2中断标记
			//参考CC1IF描述。
		//BIT1：捕获/比较1中断标记  如果通道CC1配置为输出模式：当计数器值与比较值匹配时该位由硬件置1，但在中心对称模式下除外(参考TIM1_CR1寄存器的CMS位)。它由软件清0。
			//0：无匹配发生；
			//1：TIMx_CNT的值与TIMx_CCR1的值匹配。
			//注：在中心对称模式下，当计数器值为0时，向上计数，当计数器值为ARR时，向下计数（它从0向上计数到ARR-1，再由ARR向下计数到1）。因此，对所有的SMS位值，这两个值都不置标记。但是，如果CCR1>ARR，则当CNT达到ARR值时，CC1IF置1。
			//如果通道CC1配置为输入模式：当捕获事件发生时该位由硬件置1，它由软件清0或通过读TIM1_CCR1L清0。
			//0：无输入捕获产生；
			//1：计数器值已被捕获(拷贝)至TIM1_CCR1(在IC1上检测到与所选极性相同的边沿)。
		//BIT0：更新中断标记,当产生更新事件时该位由硬件置1。它由软件清0。
			//0：无更新事件产生；
			//1：更新事件等待响应。当寄存器被更新时该位由硬件置1：
			//若TIM1_CR1寄存器的UDIS=0，当计数器上溢或下溢时；
			//若TIM1_CR1寄存器的UDIS=0、URS=0，当设置TIM1_EGR寄存器的UG位软件对计数器
			//CNT重新初始化时；
			//若TIM1_CR1寄存器的UDIS=0、URS=0，当计数器CNT被触发事件重新初始化时 (参考0
			//从模式控制寄存器TIM1_SMCR)。

    TIM1SR2 =0B00000000;
    
    TIM1EGR =0B00000000;
    //BIT7：产生刹车事件,该位由软件置1，用于产生一个刹车事件，由硬件自动清0。
			//0：无动作；
			//1：产生一个刹车事件。此时MOE=0、BIF=1，若开启对应的中断(BIE=1)，则产生相应的中断。
		//BIT6：产生触发事件,该位由软件置1，用于产生一个触发事件，由硬件自动清0。
			//0：无动作；
			//1：TIM1_SR寄存器的TIF=1，若开启对应的中断（TIE=1），则产生相应的中断。
		//BIT5：捕获/比较事件，产生控制更新该位由软件置1，由硬件自动清0。    
			//0：无动作；
			//1：当CCPC=1，允许更新CCIE、CCINE、CciP，CciNP，OCIM位。
			//注：该位只对拥有互补输出的通道有效。
		//BIT4：产生捕获/比较4事件
			//参考CC1G描述。
		//BIT3：产生捕获/比较3事件
			//参考CC1G描述。
		//BIT2：产生捕获/比较2事件
			//参考CC1G描述。
		//BIT1：产生捕获/比较1事件
			//该位由软件置1，用于产生一个捕获/比较事件，由硬件自动清0。
			//0：无动作；
			//1：在通道CC1上产生一个捕获/比较事件： 若通道CC1配置为输出：
			//设置CC1IF=1，若开启对应的中断，则产生相应的中断。若通道CC1配置为输入：
			//当前的计数器值被捕获至TIM1_CCR1寄存器，设置CC1IF=1，若开启对应的中断，则产生相应的中断。若CC1IF已经为1，则设置CC1OF=1。
		//BIT0：产生更新事件
			//该位由软件置1，由硬件自动清0。
			//0：无动作；
			//1：重新初始化计数器，并产生一个更新事件。注意预分频器的计数器也被清0(但是预分频系数不变)。若在中心对称模式下或DIR=0(向上计数)则计数器被清0；若DIR=1(向下计数)则计数器取TIM1_ARR的值。

    
    TIM1CCMR1 =0B00000001;//CC1通道被配置为输入
		//BIT7：输出比较1清零使能
			//该位用于使能使用TIM1_TRIG引脚上的外部事件来清通道１的输出信号(OC1REF)，参考17.5.9在外部事件发生时清除OCREF信号
			//0：OC1REF 不受ETRF输入（来自TIM1_TRIG引脚）的影响；
			//1：一旦检测到ETRF输入高电平，OC1REF=0。
		//BIG6~BIT4：输出比较1模式,该3位定义了输出参考信号OC1REF的动作，而OC1REF决定了OC1的值。OC1REF是高电平有效，而OC1的有效电平取决于CC1P位。
			//000：冻结。输出比较寄存器TIM1_CCR1与计数器TIM1_CNT间的比较对OC1REF不起作用；
			//001：匹配时设置通道1的输出为有效电平。当计数器TIM1_CNT的值与捕获/比较寄存器1(TIM1_CCR1)相同时，强制OC1REF为高。
			//010：匹配时设置通道1的输出为无效电平。当计数器TIM1_CNT的值与捕获/比较寄存器1(TIM1_CCR1)相同时，强制OC1REF为低。
			//011：翻转。当TIM1_CCR1=TIM1_CNT时，翻转OC1REF的电平。
			//100：强制为无效电平。强制OC1REF为低。
			//101：强制为有效电平。强制OC1REF为高。
			//110：PWM模式1－ 在向上计数时，一旦TIM1_CNT<TIM1_CCR1时通道1为有效电平，否则为无效电平；在向下计数时，一旦TIM1_CNT>TIM1_CCR1时通道1为无效电平(OC1REF=0)， 否则为有效电平(OC1REF=1)。
			//111：PWM模式2－ 在向上计数时，一旦TIM1_CNT<TIM1_CCR1时通道1为无效电平，否则为有效电平；在向下计数时，一旦TIM1_CNT>TIM1_CCR1时通道1为有效电平，否则为无效电平。
			//注1：一旦LOCK级别设为3(TIM1_BKR寄存器中的LOCK位)并且CC1S=00(该通道配置成输出) 则该位不能被修改。
			//注2：在PWM模式1或PWM模式2中，只有当比较结果改变了或在输出比较模式中从冻结模式切换到PWM模式时，OC1REF电平才改变。(参考17.5.7PWM模式)
			//注3：在有互补输出的通道上，这些位是预装载的。如果TIM1_CR2寄存器的CCPC=1，OCM 位只有在COM事件发生时，才从预装载位取新值。
		//BIT3：输出比较1预装载使能
			//0：禁止TIM1_CCR1寄存器的预装载功能，可随时写入TIM1_CCR1寄存器，并且新写入的数值立即起作用。
			//1：开启TIM1_CCR1寄存器的预装载功能，读写操作仅对预装载寄存器操作，TIM1_CCR1的预装载值在更新事件到来时被加载至当前寄存器中。
			//注1：一旦LOCK级别设为3(TIM1_BKR寄存器中的LOCK位)并且CC1S=00(该通道配置成输出) 则该位不能被修改。
			//注2：为了操作正确，在PWM模式下必须使能预装载功能。但在单脉冲模式下(TIM1_CR1寄存器的OPM=1)，它不是必须的。
		//BIT2：输出比较1 快速使能,该位用于加快CC输出对触发输入事件的响应。
			//0：根据计数器与CCR1的值，CC1正常操作，即使触发器是打开的。当触发器的输入有一个有效沿时，激活CC1输出的最小延时为5个时钟周期。
			//1：输入到触发器的有效沿的作用就象发生了一次比较匹配。因此，OC被设置为比较电平而与比较结果无关。采样触发器的有效沿和CC1输出间的延时被缩短为3个时钟周期。
			//OCFE只在通道被配置成PWM1或PWM2模式时起作用。
		//BIT1~BIT0：捕获/比较1 选择。这2位定义通道的方向(输入/输出)，及输入脚的选择：
			//00：CC1通道被配置为输出；
			//01：CC1通道被配置为输入，IC1映射在TI1FP1上；
			//10：CC1通道被配置为输入，IC1映射在TI2FP1上；
			//11：CC1通道被配置为输入，IC1映射在TRC上。此模式仅工作在内部触发器输入被选中时(由
			//TIM1_SMCR寄存器的TS位选择)。
			//注：CC1S仅在通道关闭时(TIM1_CCER1寄存器的CC1E=0)才是可写的。


    //TIM1CCMR2 =0B00000000;
    //TIM1CCMR3 =0B00000000;
    //TIM1CCMR4 =0B00000000;
    
    TIM1CCER1 =0B00000001; //上升沿触发，触发使能
    //BIT7：输入捕获/比较2互补输出极性。参考CC1NP的描述。
		//BIT6：输入捕获/比较2互补输出使能。参考CC1NE的描述。
		//BIT5：输入捕获/比较2输出极性。参考CC1P的描述。
		//BIT4：输入捕获/比较2输出使能。参考CC1E的描述。
		//BIT3：输入捕获/比较1互补输出极性
			//0：OC1N高电平有效；
			//1：OC1N低电平有效。
			//注1：一旦LOCK级别(TIM1_BKR寄存器中的LCCK位)设为3或2且CC1S=00(通道配置为输出) 则该位不能被修改。
			//注2：对于有互补输出的通道，该位是预装载的。如果CCPC=1（TIM1_CR2寄存器），只有在
			//COM事件发生时，CC1NP位才从预装载位中取新值。
		//BIT2：输入捕获/比较1互补输出使能
			//0：关闭－ OC1N禁止输出，因此OC1N的输出电平依赖于MOE、OSSI、OSSR、OIS1、
			//OIS1N和CC1E位的值。
			//1：开启－ OC1N信号输出到对应的输出引脚，其输出电平依赖于MOE、OSSI、OSSR、
			//OIS1、OIS1N和CC1E位的值。
			//注：对于有互补输出的通道，该位是预装载的。如果CCPC=1(TIM1_CR2寄存器)，只有在
			//COM事件发生时，CC1NE位才从预装载位中取新值。
		//BIT1：输入捕获/比较1输出极性CC1通道配置为输出：
			//0：OC1高电平有效；
			//1：OC1低电平有效。
			//CC1通道配置为触发(参考图61)：
			//0：触发发生在TI1F的高电平或上升沿；
			//1：触发发生在TI1F的低电平或下降沿。
			//CC1通道配置为输入(参考图61)：
			//0：捕捉发生在TI1F的高电平或上升沿；
			//1：捕捉发生在TI1F的低电平或下降沿。
			//注1：一旦LOCK级别(TIM1_BKR寄存器中的LCCK位)设为3或2，则该位不能被修改。
			//注2：对于有互补输出的通道，该位是预装载的。如果CCPC=1（TIM1_CR2寄存器），只有在
			//COM事件发生时，CC1P位才从预装载位中取新值。
		//BIT0：输入捕获/比较1输出使能
			//CC1通道配置为输出：
			//0： 关闭－ OC1禁止输出，因此OC1的输出电平依赖于MOE、OSSI、OSSR、OIS1、OIS1N和CC1NE位的值。
			//1： 开启－ OC1信号输出到对应的输出引脚，其输出电平依赖于MOE、OSSI、OSSR、OIS1 、 OIS1N 和 CC1NE 位 的 值 。                                                                                          CC1通道配置为输入：
			//该位决定了计数器的值是否能捕获入TIM1_CCR1寄存器。
			//0：捕获禁止；
			//0：捕获使能。
			//注：对于有互补输出的通道，该位是预装载的。如果CCPC=1(TIM1_CR2寄存器)，只有在
			//COM事件发生时，CC1E位才从预装载位中取新值。

    TIM1CCER2 =0B00000000;
    
    TIM1CNTRH =0B00000000;//TIM1计数器
    TIM1CNTRL =0B00000000;
    
    TIM1PSCRH =0B00000000;//计数时钟不分频
    TIM1PSCRL =0B00000000;
    
    //TIM1ARRH =0;        
    //TIM1ARRL =0;
    
    //TIM1ARRH =0x03;        //自动重载，周期
    //TIM1ARRL =0xe8;
    
    //TIM1RCR =0B00001111;   //重复计数器的值
    
    //TIM1CCR1H =0x01;       //PWM脉宽
    //TIM1CCR1L =0xf4;
    
    //TIM1CCR2H =0B00000000;
    //TIM1CCR2L =0B00000000;
    
    //TIM1CCR3H =0B00000000;
    //TIM1CCR3L =0B00000000;
    
    //TIM1CCR4H =0B00000000;
    //TIM1CCR4L =0B00000000;
    
    //TIM1BKR =0B11000000;   //输出使能，禁止刹车
    //TIM1DTR =0B00000111;   //死区发生器
    //BIT7~BIT0: 死区发生器设置,这些位定义了插入互补输出之间的死区持续时间。假设DT表示其持续时间，tCK_PSC为TIM1的时钟脉冲：
		//DTG[7:5]=0xx => DT=DTG[7:0]x tdtg，其中： tdtg=tCK_PSC.	(f1)
		//DTG[7:5]=10x => DT=(64+DTG[5:0])x tdtg，其中：tdtg= tCK_PSC.	(f2) 
		//DTG[7:5]=110 => DT=(32+DTG[4:0])x tdtg， 其 中 ：tdtg=8x tCK_PSC. (f3) 
		//DTG[7:5]=111 => DT=(32+DTG[4:0])x tdtg， 其 中 ：tdtg=16x tCK_PSC. (f4)

    //TIM1OISR =0B00000000; //空闲输出状态设置
    //BIT1：输出空闲状态1(OC1N输出)。
			//0：当MOE=0时，则在一个死区时间后，OC1N=0；
			//1：当MOE=0时，则在一个死区时间后，OC1N=1。
			//注：已经设置了LOCK(TIM1_BKR寄存器)级别1、2或3后，该位不能被修改。
		//BIT0：输出空闲状态1(OC1输出)。
			//0：当MOE=0时，如果OC1N使能，则在一个死区后，OC1=0；
			//1：当MOE=0时，如果OC1N使能，则在一个死区后，OC1=1。
			//注：已经设置了LOCK(TIM1_BKR寄存器)级别1、2或3后，该位不能被修改。

    //LEBCON =0B00000000; //前沿消隐禁止
    //BIT7	前沿消隐使能位（仅当ADGO=0时可进行切换，否则ADC工作异常）
			//1 = 使能
			//0 = 禁止
		//BIT6~BIT5:	前沿消隐通道选择
			//00 = TIM1_CH1
			//01 = TIM1_CH2
			//10 = TIM1_CH3
			//11 = TIM1_CH4
		//BIT4:N/A	保留位，读0
		//BIT3:	PWM消隐沿选择
			//0 = PWM上升沿
			//1 = PWM下降沿
		//BIT2~BIT0:TIM1的故障源使能，高有效
			//BKS2：选择ADC阈值比较
			//BKS1：选择LVD检测
			//BKS0：选择BKIN管脚
            
            T1CEN=1;
}
/*-------------------------------------------------
 *  函数名: main 
 *	功能：  主函数
 *  输入：  无
 *  输出：  无
 --------------------------------------------------*/
void main(void)
{
	POWER_INITIAL();			//系统初始化
    Time1_Capture_Initial();
    Time4Initial();
    
	while(1)
	{
    	NOP();
	}
}

