//********************************************************* 
/*  文件名: TEST_62F08x_SPI.c
*	功能：  FT62F08x-SPI功能演示
*   IC:    FT62F088 LQFP32
*   内部：  16M
*	empno: 500                                
*   说明：  此演示程序为60F12x_SPI的演示程序.
*		   该程序写0x55,0x88到(FT25C64A)0x13,0x14地址,然后读取0x13,0x14的地址值  
*		  
*
*   参考原理图 TEST_62F08x_sch.pdf
*/

//*********************************************************
#include "SYSCFG.h"
//*********************************************************
//***********************宏定义*****************************
#define  unchar     unsigned char 
#define  unint      unsigned int
#define  unlong     unsigned long

#define   CS	RB1   

//volatile  unchar mydata; //全局查看变量定义
volatile unchar 	SPIReadData=0;


/*-------------------------------------------------
 *  函数名： interrupt ISR
 *	功能：  中断处理，包括定时器0中断和外部中断
 *  输入：  无
 *  输出：  无
 --------------------------------------------------*/
void interrupt ISR(void)            	//PIC_HI-TECH使用
{ 

}

/*-------------------------------------------------
 *  函数名：POWER_INITIAL
 *	功能：  上电系统初始化
 *  输入：  无
 *  输出：  无
 --------------------------------------------------*/	
void POWER_INITIAL (void) 
{ 
	OSCCON = 0B01110001;	//WDT 32KHZ IRCF=111=16MHZ
					 		//Bit0=1,系统时钟为内部振荡器
					 		//Bit0=0,时钟源由FOSC<2：0>决定即编译选项时选择
	INTCON = 0;  			//暂禁止所有中断
    
	PORTA = 0B00000000;		
	TRISA = 0B11111110;		//PA输入输出 0-输出 1-输入
	PORTB = 0B00000000;		
	TRISB = 0B11111100;		//PB输入输出 0-输出 1-输入							
	PORTC = 0B00000000; 	
	TRISC = 0B11111111;		//PC输入输出 0-输出 1-输入  	
    PORTD = 0B00000000;		
	TRISD = 0B11111111;		//PD输入输出 0-输出 1-输入
	
	WPUA = 0B00000000;     	//PA端口上拉控制 1-开上拉 0-关上拉
	WPUB = 0B00000000;     	//PB端口上拉控制 1-开上拉 0-关上拉
	WPUC = 0B00001000;     	//PC端口上拉控制 1-开上拉 0-关上拉
	WPUD = 0B00000000;     	//PD端口上拉控制 1-开上拉 0-关上拉
    
    WPDA = 0B00000000;     	//PA端口上拉控制 1-开下拉 0-关下拉
	WPDB = 0B00000000;     	//PB端口上拉控制 1-开下拉 0-关下拉
	WPDC = 0B00000000;     	//PC端口上拉控制 1-开下拉 0-关下拉
	WPDD = 0B00000000;     	//PD端口上拉控制 1-开下拉 0-关下拉
    
    PSRC0  = 0B11111111;  	//PORTA,PORTB源电流设置最大
    //BIT7~BIT6:PORTB[7:4]源电流能力控制,BIT5~BIT4:PORTB[3:0]源电流能力控制 
    //BIT3~BIT2:PORTA[7:4]源电流能力控制,BIT1~BIT0:PORTA[3:0]源电流能力控制
    
    PSRC1  = 0B11111111;    //PORTC,PORTD源电流设置最大    
    //BIT7~BIT6:PORTD[7:4]源电流能力控制,BIT5~BIT4:PORTD[3:0]源电流能力控制 
    //BIT3~BIT2:PORTC[7:4]源电流能力控制,BIT1~BIT0:PORTC[3:0]源电流能力控制
    
    PSINK0 = 0B11111111;  	//PORTA灌电流设置最大 0:最小，1:最大
    PSINK1 = 0B11111111; 	//PORTB灌电流设置最大 0:最小，1:最大
    PSINK2 = 0B11111111;	//PORTC灌电流设置最大 0:最小，1:最大
    PSINK3 = 0B11111111;	//PORTD灌电流设置最大 0:最小，1:最大
	
    ANSELA = 0B00000000;    //全为数字管脚
}
/*------------------------------------------------- 
 *	函数名称：DelayUs
 *	功能：   短延时函数 --16M-2T--大概快1%左右.
 *	输入参数：Time延时时间长度 延时时长Time Us
 *	返回参数：无 
 -------------------------------------------------*/
void DelayUs(unsigned char Time)
{
	unsigned char a;
	for(a=0;a<Time;a++)
	{
		NOP();
	}
}                  
/*-------------------------------------------------
 *	函数名称：DelayMs
 *	功能：   短延时函数
 *	输入参数：Time延时时间长度 延时时长Time ms
 *	返回参数：无 
 -------------------------------------------------*/
void DelayMs(unsigned char Time)
{
	unsigned char a,b;
	for(a=0;a<Time;a++)
	{
		for(b=0;b<5;b++)
		{
		 	DelayUs(197); //快1%
		}
	}
}
/*-------------------------------------------------
 *	函数名称：DelayS
 *	功能：   短延时函数
 *	输入参数：Time延时时间长度 延时时长Time S
 *	返回参数：无 
 -------------------------------------------------*/
void DelayS(unsigned char Time)
{
	unsigned char a,b;
	for(a=0;a<Time;a++)
	{
		for(b=0;b<10;b++)
		{
		 	DelayMs(100); 
		}
	}
}
/*-------------------------------------------------
 *  函数名：SPI_RW
 *	功能：  主机输出以及输入一个字节
 *  输入：  data
 *  输出：  根据接收的data输出给从机一个字节
 --------------------------------------------------*/		  
unchar SPI_RW(unchar data)
{

   unchar spiData; 
   
	while(BUSY);  			//等待SPI模块空闲
    SPIDATA=data;
    while(BUSY || !SPIF);    
    SPIF=0;
    spiData = SPIDATA;
	return spiData;
 }
/*-------------------------------------------------
 *  函数名：WriteEnable
 *	功能：  写允许（将WEN置位） 
 --------------------------------------------------*/
void WriteEnable(void)
{
    CS=0;
    SPI_RW(0x06);  
    CS=1;
}
/*-------------------------------------------------
 *  函数名：WriteDisable
 *	功能：  写禁止（将WEN复位） 
 --------------------------------------------------*/
 void WriteDisable (void)
{
    CS=0;
    SPI_RW(0x04);  
    CS=1;
}
/************************************************
// 功能：读取25C64芯片的状态。
// 返回值：状态寄存器数据字节
// 注：25C64内部状态寄存器第0位=0表示空闲，0位=1表示忙。
*************************************************/
unchar SPI_ReadStatus(void)
{
    unchar status=0;
    CS=0;
    SPI_RW(0x05);                 //0x05读取状态的命令字
    status = SPI_RW(0x00);        
    CS=1;                         //关闭片选
    return status;
}  
/************************************************
*程序名：SPI_WriteStatus
*功能:  写25C64芯片的状态寄存器。
*      只有BP1、BP0 (bit7、3、2)可以写、
*注：   25c64内部状态寄存器第0位=0表示空闲，0位=1表示忙。
*************************************************/
void SPI_WriteStatus(unchar Status)
{
    CS=0;
    SPI_RW(0X01);  		          //0x01读取状态的命令字
    SPI_RW(Status);               //写入一个字节
    CS=1;                         //关闭片选
}
/*****************************************************************
程序名：SPI_Read
输入: 16位的地址
返回: 读取的数据
说明：从25c64指定的地址读取一个字节
*****************************************************************/
unchar SPI_Read(unint addr)
{
	unchar spidata;
    while(SPI_ReadStatus()&0x01);       //判断是否忙
    CS=0;                               //使能器件   
    SPI_RW(0x03);                       //发送读取命令   
    SPI_RW((unsigned char)((addr)>>8));
    SPI_RW((unsigned char)addr);
  	spidata = SPI_RW(0x00);             //读出数据  
    CS=1;  
  	return spidata;            
}
/*****************************************************************
程序名：SPI_Write
输入: 地址，字节数据
说明：将一个字节写入指定的地址
*****************************************************************/
void SPI_Write(unint addr,unchar dat)
{
    while(SPI_ReadStatus()&0x01);       //判断是否忙
    WriteEnable();                      //SET WEL
    CS=0;                               //使能器件   
    SPI_RW(0x02);   				    //发送写命令 
    SPI_RW((unchar)((addr)>>8));
    SPI_RW((unchar)addr);
    
    SPI_RW(dat);
	WriteDisable(); 
    CS=1;                               //关闭片选
    while(SPI_ReadStatus()&0x01); 
}
/*-------------------------------------------------
 *  函数名: main 
 *	功能：  主函数
 *  输入：  无
 *  输出：  无
 --------------------------------------------------*/
void SPI_INITIAL(void)
{
	PCKEN |=0B00010000;      //开启SPI时钟
	
    SPICTRL   =0B00000000;	 //
    //BIT7:传输完成标志
			//0：表示没有传输完成或者已经清零
			//1：传输完成标志位，写零清理，写1无效
		//BIT6:BUF写入失败标识，
			//0：BUF写入正常
			//1：BUF为非空时，进行写入会置位该位，写零清理，写1无效
		//BIT5:工作模式错误标识,
			//0：工作模式正常
			//1：当SPI配置为主机模式，并且NSS用作输入引脚时，若NSS引进为低电平就会产生置位该位
			//写零清零，写1无效
		//BIT4:接收溢出标志
			//0：接收正常
			//1：接收溢出，写零清理，写1无效
		//BIT3~BIT2:NSS引脚模式选择，当用作输出模式时，相应的IO脚会被用作NSS输出
			//00:禁用NSS引脚
			//01:NSS引脚用作输入
			//1x:NSS引脚用作输出，输出的值等于NSSM[0]的值
			//注：NSS引脚配置为输入状态时，可以被SSM的软件管理模式屏蔽掉
		//BIT1:发送BUFF为空状态
			//0：发送BUF非空
			//1：发送BUF位空
		//BIT0:SPI接口使能
			//0：禁用SPI模块
			//1：启用SPI模块，相应的IO会被用作SPI的功能


    SPICFG    =0B01000000;   //
    //BIT7:SPI  BUSY状态
			//0：SPI模块空闲
			//1：表示SPI模块忙绿中
		//BIT6:MASTER使能位
			//0：工作在SLAVE模式
			//1：工作在MSATER模式
		//BIT5:SCK相位选择
			//0：第一个时钟转换的沿是数据采样点
			//1：第二个时钟转换的沿是数据采样点
		//BIT4:SCK极性选择
			//0：SPI空闲时，SCK的时钟是处于低电平状态
			//1：SPI空闲时，SCK的时钟是处于高电平状态
		//BIT3:SLAVE选择标志
			//0：该模块未被选中
			//1：该模块被选中
			//注：当NSS用作输入时，该值可以被SSM软件管理，当SSM为1时，这里的值表示的是SSI的值取反
		//BIT2:NSS引脚的输入值状态
			//注：当NSS用作输入时，该值可以被SSM软件管理，当SSM为1时，这里的值表示的是SSI的值
		//BIT1:移位寄存器为空状态
			//0：内部串行移位寄存器非空
			//1：内部串行移位寄存器为空
		//BIT0:接受BUFFER为空状态
			//0：表示接收BUF非空
			//1：接收BUF为空状态

    SPISCR    =0B00000000;   //波特率设置,SPI时钟8M   16/2*(SPISCR+1)
    //SPICRCPOL =0B00000000; //CRC计算多项式，使用默认值0x07
    SPIRXCRC =0B00000000;	 	//接收数据的CRC计算结果
    SPITXCRC =0B00000000;	 	//发送数据的CRC计算结果
    SPIIER    =0B00000000;	//禁用SPI中断
    SPICTRL2  =0B00000000;
    //BIT7:半双工使能
		//0：禁用半双工模式
		//1：使能半双工模式
	//BIT6:半双工模式的接收使能
		//0：半双工模式接收使能
		//1：半双工模式发送使能
	//BIT5:全双工模式只允许接收使能
		//0：全双工模式允许发送和接收
		//1：全双工模式只允许接收
	//BIT4:NSS输入管脚的值，仅当SSM置1时有效
		//0：输入到NSS引脚的值是0
		//1：输入发哦NSS引脚的值是1
	//BIT3:软件SLAVE模式管理，使能后NSS引脚的值由SSI替代
		//0：禁用NSS引脚的软件管理模式
		//1：启用NSS引脚的关键管理模式，如果NSS引脚用作输入，则NSS引脚实际的值有SSI取代
	//BIT2:置位后在TXBUFF为空时会把TXCRC的值写入TXBUFF
		//0：不传送TXCRC的值到TXBUF
		//1：等待TXBMT为1时，传送TXCRC的值到TXBUF，写入完成后改位自动清零
	//BIT1:CRC模块计算使能
		//0：禁用CRC校验模块
		//1：启用CRC校验模块
	//BIT0:发送低比特位使能
		//0：高比特位优先发送
		//1：低比特位优先发送

    SPISTAT   =0B00000000;
    
    SPIEN=1; 				 //使能SPI
    
    //SPIF=0;  //1:传输完成标志位，写0清0
    //BUSY     //1表示SPI模块忙
    //RXBMT    //1接收BUF为空状态
    //TXBMT    //1发送BUF为空
    //SRXBMT   //1表示BUF为空状态
}
/*-------------------------------------------------
 *  函数名: main 
 *	功能：  主函数
 *  输入：  无
 *  输出：  无
 --------------------------------------------------*/
void main(void)
{
	SPIReadData=0;
	POWER_INITIAL();	//系统初始化
    SPI_INITIAL();  	//SPI初始化
    
    SPI_Write(0x0013,0x55); //写0x13地址
    SPI_Write(0x0014,0x88); //写0x14地址
    
	SPIReadData = SPI_Read(0x0013); //读取0x13地址值 
    NOP();
    SPIReadData = SPI_Read(0x0014); //读取0x14地址值 
    
	while(1)
	{
    	NOP();
	}
}

